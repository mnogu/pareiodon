#[cfg(test)]
mod tests {
    use crate::{
        icmp::{Icmp, IcmpError},
        protocol::Protocol,
    };

    #[test]
    fn icmp() {
        let buf = [
            0x08, // Type
            0x00, // Code
            0x7f, 0x57, // Checksum
            0x00, 0x2d, // Identifier
            0x00, 0x02, // Sequence Number
            0xf3, 0x89, 0x8d, 0x63, 0x00, 0x00, 0x00, 0x00, 0x35, 0xb9, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
            0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
            0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
            0x37, // Data
        ];
        let icmp = Icmp::new();
        let reply = icmp.reply(&buf);
        assert_eq!(
            reply,
            Ok(vec![
                0x00, // Type
                0x00, // Code
                0x87, 0x57, // Checksum
                0x00, 0x2d, // Identifier
                0x00, 0x02, // Sequence Number
                0xf3, 0x89, 0x8d, 0x63, 0x00, 0x00, 0x00, 0x00, 0x35, 0xb9, 0x03, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
                0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
                0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
                0x37, // Data
            ])
        );
    }

    #[test]
    fn too_short() {
        let buf = [
            0x08, // Type
            0x00, // Code
            0x7f, 0x57, // Checksum
            0x00, 0x2d, // Identifier
            0x00, // Sequence Number (missing 1 octet)
        ];
        let icmp = Icmp::new();
        let reply = icmp.reply(&buf);
        assert_eq!(reply, Err(IcmpError("too short".to_string()).into()));
    }

    #[test]
    fn wrong_checksum() {
        let buf = [
            0x08, // Type
            0x00, // Code
            0x7f, 0x56, // Checksum (wrong checksum)
            0x00, 0x2d, // Identifier
            0x00, 0x02, // Sequence Number
            0xf3, 0x89, 0x8d, 0x63, 0x00, 0x00, 0x00, 0x00, 0x35, 0xb9, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
            0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
            0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
            0x37, // Data
        ];
        let icmp = Icmp::new();
        let reply = icmp.reply(&buf);
        assert_eq!(
            reply,
            Err(IcmpError("checksum error: checksum=0x1".to_string()).into())
        );
    }
}
